# Android

## 概念

### 主线程

主线程：Main Thread，又叫 UI 线程(UI Thread)。Android应用执行的线程，所以叫主线程。

负责分发事件到合适的UI窗口，也是应用和 Android UI 套件交互的线程。所以叫 UI 线程。

### Dialog

对话框，在一个交互覆盖层中打开内容。

Dialog 就是一个在屏幕上弹出一个可以让用户做出一个选择，或者输入额外的信息的对话框，一个对话框并不会沾满我们整个的屏幕，并且通常用于模型事件当中需要用户做出一个决定后才会继续执行。

### ANR

应用无响应(application not responding)。如果 UI 线程阻塞超过几秒(现在一般是 5 秒)，用户就会看到应用无响应的 Dialog。

### 相关概念

#### 任务栈

> 一个应用对应一个任务栈，存储了此应用的所有 `Activity`。

- 任务栈
    1. 程序打开时就创建了一个任务栈, 用于存储当前程序的activity,所有的activity属于一个任务栈。 
    2. 一个任务栈包含了一个activity的集合, 去有序的选择哪一个activity和用户进行交互:只有在任务栈栈顶的activity才可以跟用户进行交互。 
    3. 任务栈可以移动到后台, 并且保留了每一个activity的状态. 并且有序的给用户列出它们的任务, 而且还不丢失它们状态信息。 
    4. 退出应用程序时：当把所有的任务栈中所有的activity清除出栈时,任务栈会被销毁,程序退出。

- 缺点：
    - 每开启一次页面都会在任务栈中添加一个Activity,而只有任务栈中的Activity全部清除出栈时，任务栈被销毁，程序才会退出,这样就造成了用户体验差, 需要点击多次返回才可以把程序退出。 
    - 每开启一次页面都会在任务栈中添加一个Activity还会造成数据冗余, 重复数据太多, 会导致内存溢出的问题(OOM)。

#### Task

> 因为任务栈的缺点，引入了 `启动模式` ，由 `Task` 进行 `Activity` 的管理。

`Task` 是一个具有栈结构的对象，它管理一个应用的多个 `Activity`，启动一个应用就启动了一个管理此应用的 `Task`。

#### 启动模式(Launch Model)

`Activity` 的启动模式可以 `AndroidManifest.xml` 文件中声明 `Activity` 的时候添加 `android:launchMode` 来声明。

##### 模式说明

- standard(默认)
    - 不管有没有实例，都生成新的实例
- singleTop
    - 检查此时栈顶Activity是否是目标Activity，如果是，不再生成新的实例，直接跳转，如果不是则生成新的实例。
    - 会回调 `onNewIntent()` 方法。
- singleTask
    - 检查栈中是否存在Activity实例，如果存在，使其上方的Activity统统出栈，使其为栈顶Activity显示。
    - 会调用实例的 `onNewIntent()`。
- singleInstance
    - 设置为此模式的Activity在start时将存在一个新的栈中。
    - 比如activity的start顺序为 A->B->C,将B设为 `singleInstance`，那么在C界面返回到的是A界面。

##### 配置方法

AndroidManifest.xml 中Activity的android:launchMode属性。

###### 使用场景
 
- singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。

- singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建。

- singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。


## 四大组件（生命周期，使用场景，如何启动）

### 概念

四大组件的概念。

#### Activity

> APP中一个 `activity` 相等于一个页面，它包含一些组件，主要用于和用户交互，一个应用程序中可以有很多个 `activity`。

#### BroadcastReceiver

> APP可以使用它对本身外部的事件进行过滤，对那些本身感兴趣的事件做出反应，例如电话呼入、数据网络连接时等。`BroadcastReceiver`本身没有页面，但是它可以启动一个`Acticity`或者`Service`来响应收到的事件信息，也可以通过`NotificationManager`来发出一个通知。

#### ContentProvider

> 内容提供者主要用于在不同应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。只有需要在多个应用程序间共享数据时才需要内容提供者。例如：通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处：统一数据访问方式。

#### Service

> 是Android中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要长期运行的任务（一边打电话，后台挂着QQ）。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另一个应用程序，服务扔然能够保持正常运行，不过服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉后，所有依赖于该进程的服务也会停止运行（正在听音乐，然后把音乐程序退出）。